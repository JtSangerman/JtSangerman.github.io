<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Breadth-First Search (BFS) Maze Demo</title>
  <style>
    body {
      margin: 0;
      background: #f7f7fa;
      font-family: 'Inter Tight', 'Segoe UI', Arial, sans-serif;
    }
    .wrapper {
      display: flex;
      flex-direction: column;
      width: 75vw;
      margin: 2rem auto;
    }
    .maze-header {
      padding-left: 15px;
      text-align: left;
      margin-bottom: 5px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .maze-title {
      font-size: 2rem;
      font-weight: 700;
      color: #a259ff;
      margin-bottom: 0;
      margin-top: 0;
      letter-spacing: -0.04em;
      font-family: 'Inter Tight', 'Segoe UI', Arial, sans-serif;
      width: max-content;
      text-align: left;
      border-bottom: 2px solid #a259ff;
      display: inline-block;
      position: relative;
    }
    .maze-title::after {
      content: "";
      position: absolute;
      left: 100%;
      bottom: -2px;
      width: 8px;
      height: 2px;
      background: #a259ff;
    }
    .maze-subtitle {
      font-size: 12px;
      font-weight: 400;
      color: #444;
      margin-bottom: 0.3rem;
      margin-top: 0;
      line-height: 1.5;
      font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
      font-style: italic;
      width: fit-content;
      text-align: left;
    }
    .maze-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    canvas {
      padding-left: 15px;
      width: 800px;
      height: 800px;
      display: block;
      background: #fff;
      box-shadow: 0 2px 16px #0001;
      border-radius: 8px;
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="maze-header">
      <h1 class="maze-title">Breadth-First Search (BFS)</h1>
      <h2 class="maze-subtitle">
        BFS is being used here as a pathfinding algorithm to find the correct path from the maze entrance to the exit by exploring all possible routes evenly until it finds a solution. In simple terms, it works like water filling every open space until it reaches the goal.
      </h2>
    </div>
    <div class="maze-container">
      <main>
        <canvas id="mazeCanvas" width="800" height="800"></canvas>
      </main>
    </div>
  </div>
  <script>
    // Maze parameters
    const rows = 24;
    const cols = 32;
    const canvas = document.getElementById('mazeCanvas');
    let cellSize = Math.min(canvas.width / cols, canvas.height / rows);

    function getOptimalCellSize(canvas) {
      return Math.min(canvas.width / cols, canvas.height / rows);
    }

    function animateFadeOut(canvas, onDone) {
      let opacity = 1;
      function fadeStep() {
        opacity -= 0.05;
        if (opacity > 0) {
          canvas.style.opacity = opacity;
          setTimeout(fadeStep, 50);
        } else {
          canvas.style.opacity = '0';
          if (onDone) onDone();
        }
      }
      fadeStep();
    }

    function animateMazeDraw(canvas, walls, cellSize, onDone) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let row = 0;
      function drawRow() {
        for (let x = 0; x < walls[0].length; x++) {
          const wx = x * cellSize;
          const wy = row * cellSize;
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 2;
          // top
          if (walls[row][x][0]) {
            ctx.beginPath();
            ctx.moveTo(wx, wy);
            ctx.lineTo(wx + cellSize, wy);
            ctx.stroke();
          }
          // right
          if (walls[row][x][1]) {
            ctx.beginPath();
            ctx.moveTo(wx + cellSize, wy);
            ctx.lineTo(wx + cellSize, wy + cellSize);
            ctx.stroke();
          }
          // bottom
          if (walls[row][x][2]) {
            ctx.beginPath();
            ctx.moveTo(wx, wy + cellSize);
            ctx.lineTo(wx + cellSize, wy + cellSize);
            ctx.stroke();
          }
          // left
          if (walls[row][x][3]) {
            ctx.beginPath();
            ctx.moveTo(wx, wy);
            ctx.lineTo(wx, wy + cellSize);
            ctx.stroke();
          }
        }
        row++;
        if (row < walls.length) {
          setTimeout(drawRow, 1000 / walls.length);
        } else {
          if (onDone) onDone();
        }
      }
      drawRow();
    }

    function generateMaze(rows, cols) {
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      const walls = Array.from({ length: rows }, () => Array(cols).fill(null).map(() => [true, true, true, true]));
      const dirs = [
        [0, -1], // up
        [1, 0],  // right
        [0, 1],  // down
        [-1, 0]  // left
      ];
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      function carve(x, y) {
        visited[y][x] = true;
        const dirOrder = shuffle([0, 1, 2, 3]);
        for (const dir of dirOrder) {
          const nx = x + dirs[dir][0];
          const ny = y + dirs[dir][1];
          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[ny][nx]) {
            walls[y][x][dir] = false;
            walls[ny][nx][(dir + 2) % 4] = false;
            carve(nx, ny);
          }
        }
      }
      carve(0, 0);
      return walls;
    }

    function solveMaze(walls, rows, cols) {
      const queue = [ [[0,0], [[0,0]]] ];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      visited[0][0] = true;
      const dirs = [ [0,-1], [1,0], [0,1], [-1,0] ];
      while (queue.length) {
        const [pos, path] = queue.shift();
        const [x, y] = pos;
        if (x === cols-1 && y === rows-1) return path;
        for (let d = 0; d < 4; d++) {
          if (!walls[y][x][d]) {
            const nx = x + dirs[d][0];
            const ny = y + dirs[d][1];
            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[ny][nx]) {
              visited[ny][nx] = true;
              queue.push([[nx, ny], [...path, [nx, ny]]]);
            }
          }
        }
      }
      return [];
    }

    function animateMazeSolution(canvas, walls, cellSize, onDone) {
      const path = solveMaze(walls, rows, cols);
      if (path.length === 0) { if (onDone) onDone(); return; }
      const ctx = canvas.getContext('2d');
      ctx.save();
      ctx.strokeStyle = '#a259ff';
      ctx.lineWidth = 6.75;
      let i = 0;
      const startX = -2 * cellSize + cellSize / 2;
      const startY = cellSize / 2;
      const endX = path[path.length-1][0]*cellSize + cellSize/2;
      const endY = path[path.length-1][1]*cellSize + cellSize/2;
      function step() {
        if (i === 0) {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(path[0][0]*cellSize + cellSize/2, path[0][1]*cellSize + cellSize/2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(path[0][0]*cellSize + cellSize/2, path[0][1]*cellSize + cellSize/2);
        }
        if (i < path.length) {
          ctx.lineTo(path[i][0]*cellSize + cellSize/2, path[i][1]*cellSize + cellSize/2);
          ctx.stroke();
          i++;
          setTimeout(step, 8);
        } else {
          ctx.lineTo(endX, endY);
          ctx.stroke();
          ctx.restore();
          if (onDone) onDone();
        }
      }
      step();
    }

    function startMazeLoop() {
      canvas.style.opacity = '1';
      cellSize = getOptimalCellSize(canvas);
      const walls = generateMaze(rows, cols);
      walls[0][0][3] = false; // open left wall at start
      walls[rows-1][cols-1][1] = false; // open right wall at finish
      animateMazeDraw(canvas, walls, cellSize, () => {
        animateMazeSolution(canvas, walls, cellSize, () => {
          setTimeout(() => {
            animateFadeOut(canvas, () => {
              startMazeLoop();
            });
          }, 1500);
        });
      });
    }

    window.onload = startMazeLoop;
  </script>
</body>
</html>